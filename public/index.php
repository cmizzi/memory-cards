<?php

use App\Http\Controllers;
use App\Http\Exceptions\HttpException;
use App\Http\Exceptions\RedirectException;
use App\Http\Response;

require_once __DIR__ . "/" . "../vendor/autoload.php";

// Start the session for each request.
session_start();

// By default, `REQUEST_URI` header returns with the query string. We don't want them to match the controller path.
$path = parse_url($_SERVER["REQUEST_URI"], PHP_URL_PATH);

// List our controllers definitions.
$controllers = [
	[ "method" => "GET"  , "path" => "/"           , "controller" => new Controllers\WelcomeController    ] ,
	[ "method" => "GET"  , "path" => "/api/scores" , "controller" => new Controllers\HighScoresController ] ,
	[ "method" => "POST" , "path" => "/api/game"   , "controller" => new Controllers\GameController       ] ,
];

// Define a global response that will be used if no route is matching the current request.
$response = new Response("Oops, the page you're looking for doesn't exist.", 404);

// Parse each controller and try to match it against the current request. The first controller which match wins.
foreach ($controllers as $controller) {
	// Check the client path with each controller path. If there's no match, continue with the next controller.
	if ($controller["path"] !== $path) {
		continue;
	}

	try {
		// Check the method. If the method does not match, we have to return a `405 Method Not Allowed` status code.
		if ($controller["method"] !== $_SERVER["REQUEST_METHOD"]) {
			throw new HttpException("Oops, the method \"{$_SERVER["REQUEST_METHOD"]}\" is not allowed for this route.", 405);
		}

		// We're on a known path, let's call the associated controller and execute the logic.
		$response = $controller["controller"]->execute();

		// Check if the controller returns a Response. If not, we have to turn the controller response into a Response
		// object to property handle the future behavior.
		if (!$response instanceof Response) {
			$response = new Response($response, 200);
		}
	}

	// In case of redirection.
	catch (RedirectException $e) {
		$response = new Response($e->path, $e->status);
	}

	// In case of generic HTTP exception.
	catch (HttpException $e) {
		$response = new Response($e->getMessage(), $e->status);
	}

	// Oops, an horrible error occurred. First, we need to response with a 500 error. Second, let's inform the user
	// something wrong happen.
	catch (Throwable $e) {
		$response = new Response($e->getMessage(), 500);
	}

	// We can safely break the loop to prevent a new iteration of the loop.
	break;
}


// Output the content generated by the controller.
$response->send();
